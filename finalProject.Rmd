---
title: "Final Project"
author: "Dr. J"
date: "11/15/2019"
output: 
  html_document:
  toc: true
  levels: 2
  number_sections: true
---

```{r setup }
knitr::opts_chunk$set(echo = TRUE)
library(DMwR2)
library(cluster)
library(factoextra)
library(tidyverse)
```

# Unsupervised learning: cluster analysis

```{r dataSets, echo=FALSE, include=FALSE}
data() # to see all the data sets available
```

## load the sales data set

```{r}
data(sales)
salesDF = na.omit(sales)
salesDF$perItem = salesDF$Val/salesDF$Quant
salesDF$Quant = as.numeric(salesDF$Quant)

head(salesDF)
```


This package includes functions and data accompanying the book
``Data Mining with R, learning with case studies'' by Luis Torgo, CRC Press 2010

The sales data set consists of sale transaction reports.  there are just over 400,000 transactions.  The entries are 

Variable |  Description
---------|----------------
ID      | employee ID number   
Prod     | product ID number 
Quant    | quantity sold
Val     |  reported value of the transaction
Insp    | categorical variable: 'ok', 'fraud', 'unkn'

Only a small percentage of the transactions have been verified as either 'ok' or 'fraud.' 
The purpose of the study is to Use cluser analysis to identify the top 50 'unkn' transactions to be investigated for possible fraud

## Next step.... 
look at the data

```{r}
fraudData = filter(salesDF, Insp=='fraud')
okData = filter(salesDF, Insp == 'ok')
fraud_ok = rbind(fraudData, okData)

```

look at a boxplot

```{r}
nFraud = length(fraudData$Val)
print(nFraud)
nOK = length(okData$Val)
print(nOK)
names=c('fraud','ok')
boxplot(log10(fraudData$Val),log10(okData$Val), names=names, horizontal = TRUE, 
        main='Transaction Values\ntotal value', xlab = 'log $$')
grid()
summary(log10(fraudData$Val))
```


The above boxplot shows that both the fraud and ok transactions have about the same dollar distributions


By the the 'per-item' quantity

```{r}

boxplot(log10(fraudData$perItem), log10(okData$perItem), names=names, horizontal = TRUE, main='Transaction Values\nitem price', xlab = 'log price per item')
grid()


```


```{r}

boxplot(log10(fraudData$Quant), log10(okData$Quant), names=names, horizontal = TRUE, main='Quantity of transactions', xlab = 'log number of transactions')
grid()


```


```{r}
fraud_okLog = fraud_ok
fraud_okLog$Quant = log10(fraud_ok$Quant)
fraud_okLog$Val = log10(fraud_ok$Val)
fraud_okLog$Val = log10(fraud_ok$perItem)
df = fraud_okLog[,c(3,4,6)]
df2 = scale(fraud_ok[,c(3,4,6)])
df = df2
```



Multiple clusters...

```{r}
k2 =kmeans(df, centers=3, nstart=20)
k3= kmeans(df, centers=4, nstart=20)
k4= kmeans(df, centers=5, nstart=20)
k5= kmeans(df, centers=6, nstart=20)
```

plots to compare

```{r comparePlots}
p1 = fviz_cluster(k2, geom='point', data =df) + ggtitle('k=3')
p2 = fviz_cluster(k3, geom='point', data =df) + ggtitle('k=4')
p3 = fviz_cluster(k4, geom='point', data =df) + ggtitle('k=5')
p4 = fviz_cluster(k5, geom='point', data =df) + ggtitle('k=6')

library(gridExtra)
grid.arrange(p1, p2, p3, p4, nrow=2)
```


```{r withinClusterPlot }
was = function(k) {
  kmeans(df, centers=k, nstart=25)$tot.withinss 
}

# compute and plot for k=1 to k=10
k.values=2:10

# extract was for 2-10 clusters
was.values = map_dbl(k.values, was)
print('silhouette values: ')
for (i in 2:10) print(paste(i," ", was.values[i]," ", was.values[i]/was.values[1]*100,"%"))

plot(k.values, was.values, type='b', pch=19, frame=FALSE, 
     xlab = 'number of clusters', ylab='total within-clusters SS')
grid()
```



## final result

```{r}
final = kmeans(df,6, nstart=50)
fviz_cluster(final, geom='point', data = df) + ggtitle('optimum clusters')
```

print cluster results:

```{r}
nObs = length(df[,1])
for (i in 1:6){
  print(paste('Cluster ',i))
  clusterIndex = which(final$cluster==i)
  fraudCount = length(which(fraud_ok[clusterIndex,5] == 'fraud'))
  okCount = length(which(fraud_ok[clusterIndex,5]=='ok'))
  print(paste('fraud = ', fraudCount, ' ok = ', okCount))
  print(paste('fraud = ', round(fraudCount/(fraudCount+okCount)*100),'%'))
  print('-------')
}

```


